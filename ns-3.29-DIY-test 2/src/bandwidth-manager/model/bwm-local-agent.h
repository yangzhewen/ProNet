#ifndef BWM_LOCAL_AGENT_H
#define BWM_LOCAL_AGENT_H

#include "ns3/object.h"
#include "ns3/application.h"
#include "ns3/timer.h"
#include "ns3/ipv4-address.h"
#include "ns3/ipv4.h"
#include "ns3/tbf-queue-disc.h"
#include <list>
#include <map>
#include <vector>

namespace ns3 {

class UnitFlow;
class BwmCoordinator;
class BwmQueueDisc;
class BwmQueueDiscClass;

/**
 * \ingroup bandwidth-manager
 *
 * \brief A class describing local agents in the bandwidth-manager system
 * 
 * A local agent in the bandwidth-manager system takes charge of
 * collecting info of local unit flows,
 * reporting usage,
 * etc.
 */
class BwmLocalAgent : public Application {
public:
  /**
   * \brief Get the type ID.
   * \return the object TypeId
   */
  static TypeId GetTypeId (void);

  /**
   * \brief BwmLocalAgent constructor.
   */
  BwmLocalAgent ();

  ~BwmLocalAgent ();

  /**
   * \brief The iterator of the scoreboard.
   */
  typedef std::map<uint32_t, std::vector<uint32_t>>::iterator SBIterator;
  /**
   * \brief The flags of each unit in a scoreboard line
   * SPC: sample counter
   * NMB: normal bytes
   * CEB: congestion encountered bytes
   * LMT: last modified time in ns
   * SRC: source IP address
   * SBL_SIZE: size of each scoreboard line
   */
  enum ScoreboardUnit { SPC, NMB, CEB, LMT, SRC, SBL_SIZE};

  /**
   * \brief Set a id to the host.
   */
  void SetHostId (uint32_t hostId);
  /**
   * \brief Get the id of host.
   * \return the id of host
   */
  uint32_t GetHostId (void);
  /**
   * \brief Link a bwm queue disc to this host.
   */
  void SetQueueDisc (Ptr<BwmQueueDisc> qdisc);
  /**
   * \brief Link a bwm coordinator to this host.
   */
  void SetCoordinator (Ptr<BwmCoordinator> coordinator);
  /**
   * \brief Check whether the ip address belongs to this host.
   * \return true if the addr belongs to the host, false otherwise
   */
  bool CheckIP (Ipv4Address addr);
  /**
   * \brief Set the new target status which will be used to tune rate limits for all local unit flows.
   */
  void SetNewTargetStatus (double);
  /**
   * \brief Register a new unit flow into the local agent.
   * \return the flow pointer if the operation succeed, NULL otherwise.
   */
  Ptr<UnitFlow> AddNewUnitFlow (uint32_t tenantId, uint32_t flowId, uint32_t traceId, Ptr<BwmQueueDiscClass> qDiscClass, Ipv4Address src, Ipv4Address dst);
  /**
   * \brief Assign a new id to a new unit flow belonging to the local agent.
   * \return the flow id generated by hash function on tenantId, src addr and dst addr.
   */
  uint32_t AssignFlowId (uint32_t tenantId, Ipv4Address src, Ipv4Address dst);
  /**
   * \brief Periodically update the status of agent.
   * 
   * This method will be scheduled by the timer and it invokes ReportUsage,
   * TuneRates and ClearUsage methods.
   */
  void Update ();

  /**
   * \brief Setup Congestion-Aware Work-Conserving mechanism.
   * 
   * This method connect the RxTrace of Ipv4 Layer to the RxHandle
   * and set up the timer for periodical work-conserving rate updateing.
   */
  void SetupCAWC(Ptr<Ipv4> ipv4);
  /**
   * \brief Check each entry of the scoreboard and selectively send feedback.
   * 
   * This method will check the sample count in each entry of the scoreboard.
   * If the SPC is higher than one fifth of the feedback threshold, actively 
   * send feedback to the sender.
   */
  void CAWCCheck ();
  /**
   * \brief Handle each received packet.
   * 
   * This method will be connected to the RxTrace of Ipv4 Layer.
   * 
   */
  static void RxHandler (Ptr<BwmLocalAgent> agent, Ptr<const Packet> packet, Ptr<Ipv4> ipv4, uint32_t interface);
  /**
   * \brief Update the scoreboard of a unit flow.
   * 
   * This method will be called by the Ipv4 Layer to 
   * record congestion condition of each unit flow.
   * 
   * The flag conforms the scoreboard unit flags
   */
  void UpdateScoreboard (uint32_t flowId, int flag, uint32_t size, Ipv4Header ipHeader, Ptr<Ipv4> ipv4);
  /**
   * \brief Add an entry to the scoreboard for an incoming unit flow.
   * 
   * This method will be called by the Ipv4 Layer to 
   * create an entry in the scoreboard when the Ipv4 Layer 
   * receive a packet from a new unit-flow
   */
  void AddSBEntry (uint32_t flowId, uint32_t srcIp);
  /**
   * \brief Update congestion factor of a unit flow.
   *
   * The flowId argument is actually the traceId carried in FlowIdTag
   */
  void UpdateCongestionFactor (uint32_t flowId, float factor);
private:
  /**
   * \brief Start up the application.
   */
  void StartApplication (void);
  /**
   * \brief Shut down the application.
   */
  void StopApplication (void);
  /**
   * \brief Collect & report usage information from all unit flows.
   */
  void ReportUsage ();
  /**
   * \brief Reset usage statistics of all unit flows.
   */
  void ClearUsage ();
  /**
   * \brief Use Distributed Edge Optimization Algorithm to tune rates of all unit flows.
   */
  void TuneRates ();

  std::list<std::pair<Ptr<UnitFlow>, Ptr<BwmQueueDiscClass>>> m_flowTable; //!< Flow table of the local host
  Ptr<BwmCoordinator> m_coordinator; //!< Corresponding central coordinator
  Ptr<BwmQueueDisc> m_qdisc; //!< Corresponding local BwM queue disc
  uint32_t m_hostId; //!< The unique id used to identify this host
  Ipv4Address m_ipv4Addr; //!< The local ipv4 address

  Timer m_timer; //!< The timer used to report usage & update status
  Timer m_subTimer; //!< The timer used to tune rates
  double m_k; //!< Learning rate used in distributed edge optimization
  Time m_reportCycle; //!< The collecting & update cycle
  Time m_tuneCycle; //!< The rate tunning cycle
  double m_targetStatus; //!< Target status used in distributed edge optimization
  double m_deviceRateLimit; //!< The limit caused by the fixed device rate
  bool m_deviceRateLimitFlag; //!< The flag used to indicate whether the sum of rate achieve the device rate limit

  bool m_CAWCEnable; //!< The enable flag of CAWC mechanism
  Timer m_feedbackTimer; //!< The timer used to update work-conserving rate
  Time m_feedbackCycle; //!< The update cycle
  uint32_t m_feedbackThreshold; //!< The feedback threshold of update
  double m_congestionThreshold; //!< The congestion threshold of each unit flow
  std::map<uint32_t, std::vector<uint64_t>> m_scoreboard; //!< The scoreboard used to estimate congestion condition
};

}

#endif
